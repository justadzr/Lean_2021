import tactic
import analysis.complex.basic
import data.matrix.notation
import linear_algebra.matrix.determinant
import analysis.normed_space.inner_product

noncomputable theory

section conformal

-- Should the field `ùïú` here be `is_R_or_C` or just simply `‚Ñù`?

/-!
Failed to build conformal maps on general `inner_product_space`. Instead, focus on Euclidean spaces.
-/

def conformal_at 
{X Y : Type*} [inner_product_space ‚Ñù X] [inner_product_space ‚Ñù Y] 
(f : X ‚Üí Y) (x : X) :=
‚àÉ (f' : X ‚ÜíL[‚Ñù] Y) (c : ‚Ñù) (lie : X ‚âÉ‚Çó·µ¢[‚Ñù] Y),
has_fderiv_at f f' x ‚àß ¬¨ c = 0 ‚àß ‚áëf' = (Œª y, c ‚Ä¢ y) ‚àò lie

def conformal 
{X Y : Type*} [inner_product_space ‚Ñù X] [inner_product_space ‚Ñù Y]
(f : X ‚Üí Y) :=
‚àÄ (x : X), conformal_at f x

variables {X Y : Type*} [inner_product_space ‚Ñù X] [inner_product_space ‚Ñù Y] 

theorem conformal_at.differentiable_at {f : X ‚Üí Y} {x : X} (h : conformal_at f x) :
differentiable_at ‚Ñù f x := let ‚ü®f', c, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h in h‚ÇÅ.differentiable_at

theorem conformal.differentiable {f : X ‚Üí Y} (h : conformal f) :
differentiable ‚Ñù f := Œª x, (h x).differentiable_at

theorem conformal_at.id (x : X) : conformal_at id x := 
‚ü®continuous_linear_map.id ‚Ñù X, 1, linear_isometry_equiv.refl ‚Ñù X, ‚ü®has_fderiv_at_id _, one_ne_zero, by ext; simp‚ü©‚ü©

theorem conformal.id : conformal (id : X ‚Üí X) := Œª x, conformal_at.id x

theorem conformal_at.const_smul {c : ‚Ñù} (h : ¬¨ c = 0) (x : X) : conformal_at (Œª (x': X), c ‚Ä¢ x') x :=
‚ü®c ‚Ä¢ continuous_linear_map.id ‚Ñù X, c, linear_isometry_equiv.refl ‚Ñù X, ‚ü®by apply has_fderiv_at.const_smul (has_fderiv_at_id x) c; simp, h, by ext; simp‚ü©‚ü©

theorem conformal.const_smul {c : ‚Ñù} (h : ¬¨ c = 0) : 
conformal (Œª (x : X), c ‚Ä¢ x) := Œª x, conformal_at.const_smul h x

variables {Z : Type*} [inner_product_space ‚Ñù Z]

theorem conformal_at.comp {f : X ‚Üí Y} {g : Y ‚Üí Z} {x : X} 
(hf : conformal_at f x) (hg : conformal_at g (f x)) :
conformal_at (g ‚àò f) x :=
begin
  rcases hf with ‚ü®f', cf, lief, hf‚ÇÅ, hf‚ÇÇ, hf‚ÇÉ‚ü©,
  rcases hg with ‚ü®g', cg, lieg, hg‚ÇÅ, hg‚ÇÇ, hg‚ÇÉ‚ü©,
  use [g'.comp f', cg * cf, lief.trans lieg],
  exact ‚ü®has_fderiv_at.comp x hg‚ÇÅ hf‚ÇÅ, 
        mul_ne_zero hg‚ÇÇ hf‚ÇÇ, 
        by ext; rw [continuous_linear_map.coe_comp' f' g', hf‚ÇÉ, hg‚ÇÉ]; 
        simp; exact smul_smul cg cf _‚ü©,
end

theorem conformal.comp {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : conformal f) (hg : conformal g) :
conformal (g ‚àò f) := Œª x, conformal_at.comp (hf x) (hg (f x))

theorem conformal_at_iff {f : X ‚Üí Y} {x : X} {f' : X ‚âÉL[‚Ñù] Y}
(h : has_fderiv_at f f'.to_continuous_linear_map x) :
conformal_at f x ‚Üî ‚àÉ (c : ‚Ñù) (hc : c > 0), ‚àÄ (u v : X), inner (f' u) (f' v) = (c : ‚Ñù) * (inner u v) :=
begin
  split,
  {
    intros h',
    rcases h' with ‚ü®f‚ÇÅ, c‚ÇÅ, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©,
    use [c‚ÇÅ ^ 2, sq_pos_of_ne_zero _ h‚ÇÇ],
    intros u v,
    rw [‚Üê continuous_linear_equiv.coe_coe f', 
        ‚Üê continuous_linear_equiv.coe_def_rev f', has_fderiv_at.unique h h‚ÇÅ, h‚ÇÉ],
    simp only [function.comp_apply, real_inner_smul_left, real_inner_smul_right, 
               linear_isometry_equiv.inner_map_map],
    rw [‚Üê mul_assoc, pow_two],
  },
  {
    intros h',
    rcases h' with ‚ü®c‚ÇÅ, hc‚ÇÅ, huv‚ü©,
    let c := real.sqrt c‚ÇÅ‚Åª¬π,
    have hc : ¬¨ c = 0 := Œª w, by simp only [c] at w; 
      exact (real.sqrt_ne_zero'.mpr $ inv_pos.mpr hc‚ÇÅ) w,
    let c_map := linear_equiv.smul_of_ne_zero ‚Ñù Y c hc,
    let f‚ÇÅ := f'.to_linear_equiv.trans c_map,
    have minor : ‚áëf‚ÇÅ = (Œª (y : Y), c ‚Ä¢ y) ‚àò f' := rfl,
    have minor' : ‚áëf' = (Œª (y : Y), c‚Åª¬π ‚Ä¢ y) ‚àò f‚ÇÅ := by ext;
      rw [minor, function.comp_apply, function.comp_apply, 
          smul_smul, inv_mul_cancel hc, one_smul],
    have key : ‚àÄ (u v : X), inner (f‚ÇÅ u) (f‚ÇÅ v) = inner u v := Œª u v, by
      rw [minor, function.comp_app, function.comp_app, real_inner_smul_left, 
          real_inner_smul_right, huv u v, ‚Üê mul_assoc, ‚Üê mul_assoc, 
          real.mul_self_sqrt $ le_of_lt $ inv_pos.mpr hc‚ÇÅ, 
          inv_mul_cancel $ ne_of_gt hc‚ÇÅ, one_mul],
    exact ‚ü®f'.to_continuous_linear_map, c‚Åª¬π, f‚ÇÅ.isometry_of_inner key, 
            ‚ü®h, inv_ne_zero hc, minor'‚ü©‚ü©,
  },
end

def conformal_at.char_fun {f : X ‚Üí Y} (x : X) {f' : X ‚âÉL[‚Ñù] Y}
(h : has_fderiv_at f f'.to_continuous_linear_map x) (H : conformal_at f x) : ‚Ñù :=
by choose c hc huv using (conformal_at_iff h).mp H; exact c

def inner_product_angle (u v : X) : ‚Ñù :=
inner u v / (‚à•u‚à• * ‚à•v‚à•)
@[simp] theorem inner_product_angle.def {u v : X} :
inner_product_angle u v = inner u v / (‚à•u‚à• * ‚à•v‚à•) := rfl

theorem conformal_at_preserves_angle {f : X ‚Üí Y} {x : X} {f' : X ‚âÉL[‚Ñù] Y}
(h : has_fderiv_at f f'.to_continuous_linear_map x) (H : conformal_at f x) :
‚àÄ (u v : X), inner_product_angle (f' u) (f' v) = (inner_product_angle u v : ‚Ñù) :=
begin
  intros u v, 
  rcases H with ‚ü®f‚ÇÅ, c‚ÇÅ, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©,
  have minor : ¬¨ ‚à•c‚ÇÅ‚à• = 0 := Œª w, h‚ÇÇ (norm_eq_zero.mp w),
  have : f'.to_continuous_linear_map = f‚ÇÅ := has_fderiv_at.unique h h‚ÇÅ,
  rw [‚Üê continuous_linear_equiv.coe_coe f', ‚Üê continuous_linear_equiv.coe_def_rev f'],
  repeat {rw inner_product_angle.def},
  rw [this, h‚ÇÉ],
  repeat {rw function.comp_apply},
  rw [real_inner_smul_left, real_inner_smul_right, ‚Üê mul_assoc, 
      linear_isometry_equiv.inner_map_map],
  repeat {rw [norm_smul, linear_isometry_equiv.norm_map]},
  rw [‚Üê mul_assoc],
  exact calc c‚ÇÅ * c‚ÇÅ * inner u v / (‚à•c‚ÇÅ‚à• * ‚à•u‚à• * ‚à•c‚ÇÅ‚à• * ‚à•v‚à•) 
          = c‚ÇÅ * c‚ÇÅ * inner u v / (‚à•c‚ÇÅ‚à• * ‚à•c‚ÇÅ‚à• * ‚à•u‚à• * ‚à•v‚à•) : by simp only [mul_comm, mul_assoc]
      ... = c‚ÇÅ * c‚ÇÅ * inner u v / (abs c‚ÇÅ * abs c‚ÇÅ * ‚à•u‚à• * ‚à•v‚à•) : by rw [real.norm_eq_abs]
      ... = c‚ÇÅ * c‚ÇÅ * inner u v / (c‚ÇÅ * c‚ÇÅ * ‚à•u‚à• * ‚à•v‚à•) : by rw [‚Üê pow_two, ‚Üê sq_abs, pow_two]
      ... = c‚ÇÅ * (c‚ÇÅ * inner u v) / (c‚ÇÅ * (c‚ÇÅ * (‚à•u‚à• * ‚à•v‚à•))) : by simp only [mul_assoc]
      ... = (c‚ÇÅ * inner u v) / (c‚ÇÅ * (‚à•u‚à• * ‚à•v‚à•)) : by rw mul_div_mul_left _ _ h‚ÇÇ
      ... = inner u v / (‚à•u‚à• * ‚à•v‚à•) : by rw mul_div_mul_left _ _ h‚ÇÇ,
end

end conformal

section complex_conformal

open complex

variables {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ}

-- This is a baby version of the Jacobian of a real differentiable complex function

def complex_jacobian_at (h : differentiable_at ‚Ñù f z) : matrix (fin 2) (fin 2) ‚Ñù :=
![![fderiv ‚Ñù (re ‚àò f) z 1, fderiv ‚Ñù (re ‚àò f) z I], ![fderiv ‚Ñù (im ‚àò f) z 1, fderiv ‚Ñù (im ‚àò f) z I]]

@[simp] theorem complex_jacobian_at.def (h : differentiable_at ‚Ñù f z) :
complex_jacobian_at h = ![![fderiv ‚Ñù (re ‚àò f) z 1, fderiv ‚Ñù (re ‚àò f) z I], 
                          ![fderiv ‚Ñù (im ‚àò f) z 1, fderiv ‚Ñù (im ‚àò f) z I]] := rfl

@[simp] theorem complex_jacobian_at_det_eq (h : differentiable_at ‚Ñù f z) :
(complex_jacobian_at h).det = (fderiv ‚Ñù (re ‚àò f) z 1) * fderiv ‚Ñù (im ‚àò f) z I - (fderiv ‚Ñù (re ‚àò f) z I) * fderiv ‚Ñù (im ‚àò f) z 1 :=
begin
  rw matrix.det_succ_row_zero, repeat {rw [fin.sum_univ_succ]}, simp_rw [fin.sum_univ_zero],
  simp, rw ‚Üê sub_eq_add_neg _ _,
end

-- Time saving stuff

@[simp] theorem cmatrix_two_apply00 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 0 0 = a := rfl
@[simp] theorem cmatrix_two_apply01 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 0 1 = b := rfl
@[simp] theorem cmatrix_two_apply10 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 1 0 = c := rfl
@[simp] theorem cmatrix_two_apply11 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 1 1 = d := rfl
@[simp] theorem rmatrix_two_apply00 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 0 0 = a := rfl
@[simp] theorem rmatrix_two_apply01 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 0 1 = b := rfl
@[simp] theorem rmatrix_two_apply10 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 1 0 = c := rfl
@[simp] theorem rmatrix_two_apply11 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 1 1 = d := rfl

@[simp] theorem cvec_two_apply (a b : ‚ÑÇ) : ![a, b] 0 = a := rfl
@[simp] theorem cvec_two_apply' (a b : ‚ÑÇ) : ![a, b] 1 = b := rfl
@[simp] theorem rvec_two_apply (a b : ‚Ñù) : ![a, b] 0 = a := rfl
@[simp] theorem rvec_two_apply' (a b : ‚Ñù) : ![a, b] 1 = b := rfl

lemma quick_re (z : ‚ÑÇ) : has_fderiv_at re re_clm z := re_clm.has_fderiv_at
lemma quick_re' (z : ‚ÑÇ) : differentiable_at ‚Ñù re z := (quick_re z).differentiable_at
lemma quick_re'' (z : ‚ÑÇ) : fderiv ‚Ñù re z = re_clm := (quick_re z).fderiv
lemma quick_re_comp (z z': ‚ÑÇ) (h : differentiable_at ‚Ñù f z) : (fderiv ‚Ñù f z z').re = fderiv ‚Ñù (re ‚àò f) z z' :=
begin
  rw fderiv.comp z (quick_re' $ f z) h,
  simp only [function.app, function.comp_app, continuous_linear_map.coe_comp'],
  rw [quick_re'' (f z), re_clm_apply],
end


lemma quick_im (z : ‚ÑÇ) : has_fderiv_at im im_clm z := im_clm.has_fderiv_at
lemma quick_im' (z : ‚ÑÇ) : differentiable_at ‚Ñù im z := (quick_im z).differentiable_at
lemma quick_im'' (z : ‚ÑÇ) : fderiv ‚Ñù im z = im_clm := (quick_im z).fderiv
lemma quick_im_comp (z z': ‚ÑÇ) (h : differentiable_at ‚Ñù f z) : (fderiv ‚Ñù f z z').im = fderiv ‚Ñù (im ‚àò f) z z' :=
begin
  rw fderiv.comp z (quick_im' $ f z) h,
  simp only [function.app, function.comp_app, continuous_linear_map.coe_comp'],
  rw [quick_im'' (f z), im_clm_apply],
end
/-!
## Important:
The following two lemmas are modified versions of Cauchy-Riemann equations written by [hrmacbeth](https://github.com/hrmacbeth) 
in the file `complex.basic` in the `complex-diff` branch of mathlib. Some theorems in that branch conflict with
the current mathlib, which contains the most essential `linear_isometry_equiv` we need.
-/

/-- First Cauchy-Riemann equation: for a complex-differentiable function `f`, the `x`-derivative of
`re ‚àò f` is equal to the `y`-derivative of `im ‚àò f`. -/
theorem fderiv_re_comp_eq_fderiv_im_comp (h : differentiable_at ‚ÑÇ f z) :
  fderiv ‚Ñù (re ‚àò f) z 1 = fderiv ‚Ñù (im ‚àò f) z I :=
begin
  let hz := h.has_fderiv_at.restrict_scalars ‚Ñù,
  have hI : I = I ‚Ä¢ 1 := by simp,
  simp only [continuous_linear_map.coe_comp', continuous_linear_map.coe_restrict_scalars', function.comp_app, 
            ((quick_re $ f z).comp z hz).fderiv, ((quick_im $ f z).comp z hz).fderiv],
  rw [hI, continuous_linear_map.map_smul],
  simp,
end

/-- Second Cauchy-Riemann equation: for a complex-differentiable function `f`, the `x`-derivative of
`im ‚àò f` is equal to the negative of the `y`-derivative of `re ‚àò f`. -/
theorem fderiv_re_comp_eq_neg_fderiv_im_comp (h : differentiable_at ‚ÑÇ f z) :
  fderiv ‚Ñù (re ‚àò f) z I = - fderiv ‚Ñù (im ‚àò f) z 1 :=
begin
  have hz := h.has_fderiv_at.restrict_scalars ‚Ñù,
  have hI : I = I ‚Ä¢ 1 := by simp,
  simp only [continuous_linear_map.coe_comp', continuous_linear_map.coe_restrict_scalars', function.comp_app,
            ((quick_re $ f z).comp z hz).fderiv, ((quick_im $ f z).comp z hz).fderiv],
  rw [hI, continuous_linear_map.map_smul],
  simp,
end

theorem real_fderiv_to_matrix (h : differentiable_at ‚Ñù f z) : 
(linear_map.to_matrix complex.basis_one_I complex.basis_one_I) (fderiv ‚Ñù f z) = complex_jacobian_at h :=
begin
  ext,
  rw linear_map.to_matrix_apply _ _ _ _ _,
  simp only [coe_basis_one_I, coe_basis_one_I_repr],
  fin_cases i,
  { 
    fin_cases j,
    {
      repeat {rw cvec_two_apply}, rw rvec_two_apply,
      simp only [complex_jacobian_at, rmatrix_two_apply00],
      exact quick_re_comp z 1 h,
    },
    {
      repeat {rw cvec_two_apply'}, rw rvec_two_apply,
      simp only [complex_jacobian_at, rmatrix_two_apply01],
      exact quick_re_comp z I h,
    },
  },
  { 
    fin_cases j,
    {
      repeat {rw cvec_two_apply}, rw rvec_two_apply',
      simp only [complex_jacobian_at, rmatrix_two_apply10],
      exact quick_im_comp z 1 h,
    },
    {
      repeat {rw cvec_two_apply}, rw rvec_two_apply',
      simp only [complex_jacobian_at, rmatrix_two_apply11],
      exact quick_im_comp z I h,
    },
  },
end

theorem fderiv_decomp (h : differentiable_at ‚ÑÇ f z) :
fderiv ‚ÑÇ f z 1 = fderiv ‚Ñù (re ‚àò f) z 1 + (fderiv ‚Ñù (im ‚àò f) z 1) * I :=
begin
  let h' := h.restrict_scalars ‚Ñù,
  have : fderiv ‚ÑÇ f z 1 = (fderiv ‚ÑÇ f z 1).re + (fderiv ‚ÑÇ f z 1).im * I := 
    by simp only [re_add_im],
  have triv := has_fderiv_at.unique h'.has_fderiv_at (h.has_fderiv_at.restrict_scalars ‚Ñù),
  rw [this, ‚Üê quick_re_comp z 1 h', ‚Üê quick_im_comp z 1 h', 
      triv, continuous_linear_map.coe_restrict_scalars'],
end

theorem fderiv_decomp' (h : differentiable_at ‚ÑÇ f z) :
fderiv ‚ÑÇ f z 1 = (fderiv ‚Ñù f z 1).re + (fderiv ‚Ñù f z 1).im * I :=
(quick_re_comp z 1 $ h.restrict_scalars ‚Ñù).symm ‚ñ∏ ((quick_im_comp z 1 $ h.restrict_scalars ‚Ñù).symm ‚ñ∏ fderiv_decomp h)

theorem complex_jacobian_det_eq_fderiv_norm_sq (h : differentiable_at ‚ÑÇ f z) :
(complex_jacobian_at $ h.restrict_scalars ‚Ñù).det = norm_sq (fderiv ‚ÑÇ f z 1) :=
begin
  let h' := h.restrict_scalars ‚Ñù,
  rw [complex_jacobian_at_det_eq, ‚Üê fderiv_re_comp_eq_fderiv_im_comp h, 
    fderiv_re_comp_eq_neg_fderiv_im_comp h],
  rw [‚Üê neg_mul_eq_neg_mul, sub_neg_eq_add, 
      ‚Üê quick_re_comp z 1 h', ‚Üê quick_im_comp z 1 h', fderiv_decomp' h],
  simp only [norm_sq_apply, re_add_im],
end

@[simp] theorem complex_jacobian_det_eq_zero_iff (h : differentiable_at ‚ÑÇ f z) :
(complex_jacobian_at $ h.restrict_scalars ‚Ñù).det = 0 ‚Üî fderiv ‚ÑÇ f z 1 = 0 := by rw complex_jacobian_det_eq_fderiv_norm_sq h; simp

@[simp] theorem complex_jacobian_det_ne_zero_iff (h : differentiable_at ‚ÑÇ f z) :
¬¨ (complex_jacobian_at $ h.restrict_scalars ‚Ñù).det = 0 ‚Üî ¬¨ fderiv ‚ÑÇ f z 1 = 0 := not_iff_not_of_iff $ complex_jacobian_det_eq_zero_iff h

/-
I could only do this for holomorphic/antiholomorphic + nonzero Jacobian ‚Üí conformal, but couldn't show
conformal + nonzero Jacobian ‚Üí holomorphic ‚à® antiholomorphic because Cauchy-Riemann ‚Üí holomorphic
is not proved yet.
-/

theorem conformal_at_if_holomorph_deriv_ne_zero
{f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (h : differentiable_at ‚Ñù f z) (H : ¬¨ (complex_jacobian_at h).det = 0) :
(differentiable_at ‚ÑÇ f z ‚à® ‚àÉ (g : ‚ÑÇ ‚Üí ‚ÑÇ) (hg : differentiable_at ‚ÑÇ g z), f = conj ‚àò g) ‚Üí
conformal_at f z := Œª p,
begin
  cases p,
  {

  },
  {
    sorry,
  },
end

end complex_conformal

-- def conformal_at 
-- (ùïú : Type*) [is_R_or_C ùïú] {X Y : Type*} 
-- [inner_product_space ùïú X] [normed_space ‚Ñù X] [is_scalar_tower ‚Ñù ùïú X] 
-- [inner_product_space ùïú Y] [normed_space ‚Ñù Y] [is_scalar_tower ‚Ñù ùïú Y] 
-- (f : X ‚Üí Y) (x : X) :=
-- ‚àÉ (f' : X ‚ÜíL[‚Ñù] Y) (c : ùïú) (lie : X ‚âÉ‚Çó·µ¢[ùïú] Y),
-- has_fderiv_at f f' x ‚àß ¬¨ c = 0 ‚àß ‚áëf' = (Œª y, c ‚Ä¢ y) ‚àò lie

-- def conformal 
-- (ùïú : Type*) [is_R_or_C ùïú] {X Y : Type*} 
-- [inner_product_space ùïú X] [normed_space ‚Ñù X] [is_scalar_tower ‚Ñù ùïú X] 
-- [inner_product_space ùïú Y] [normed_space ‚Ñù Y] [is_scalar_tower ‚Ñù ùïú Y] 
-- (f : X ‚Üí Y) :=
-- ‚àÄ (x : X), conformal_at ùïú f x

-- variables {ùïú : Type*} [is_R_or_C ùïú] {X Y : Type*} 
-- [inner_product_space ùïú X] [normed_space ‚Ñù X] [is_scalar_tower ‚Ñù ùïú X] 
-- [inner_product_space ùïú Y] [normed_space ‚Ñù Y] [is_scalar_tower ‚Ñù ùïú Y]

-- theorem conformal_at.differentiable_at {f : X ‚Üí Y} {x : X} (h : conformal_at ùïú f x) :
-- differentiable_at ‚Ñù f x := let ‚ü®f', c, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h in h‚ÇÅ.differentiable_at

-- theorem conformal.differentiable {f : X ‚Üí Y} (h : conformal ùïú f) :
-- differentiable ‚Ñù f := Œª x, (h x).differentiable_at

-- theorem conformal_at.id (x : X) : conformal_at ùïú id x := 
-- ‚ü®continuous_linear_map.id ‚Ñù X, 1, linear_isometry_equiv.refl ‚Ñù X, ‚ü®has_fderiv_at_id _, one_ne_zero, by ext; simp‚ü©‚ü©

-- theorem conformal.id : conformal ùïú (id : X ‚Üí X) := Œª x, conformal_at.id x

-- theorem conformal_at.const_smul {c : ùïú} (h : ¬¨ c = 0) (x : X) : conformal_at ùïú (Œª (x': X), c ‚Ä¢ x') x :=
-- ‚ü®c ‚Ä¢ continuous_linear_map.id ‚Ñù X, c, linear_isometry_equiv.refl ‚Ñù X, ‚ü®by apply has_fderiv_at.const_smul (has_fderiv_at_id x) c; simp, h, by ext; simp‚ü©‚ü©

-- theorem conformal.const_smul {c : ùïú} (h : ¬¨ c = 0) : 
-- conformal ùïú (Œª (x : X), c ‚Ä¢ x) := Œª x, conformal_at.const_smul h x

-- variables {Z : Type*} [inner_product_space ùïú Z] [normed_space ‚Ñù Z] [is_scalar_tower ‚Ñù ùïú Z]

-- theorem conformal_at.comp {f : X ‚Üí Y} {g : Y ‚Üí Z} {x : X} 
-- (hf : conformal_at ùïú f x) (hg : conformal_at ùïú g (f x)) :
-- conformal_at ùïú (g ‚àò f) x :=
-- begin
--   rcases hf with ‚ü®f', cf, lief, hf‚ÇÅ, hf‚ÇÇ, hf‚ÇÉ‚ü©,
--   rcases hg with ‚ü®g', cg, lieg, hg‚ÇÅ, hg‚ÇÇ, hg‚ÇÉ‚ü©,
--   use [g'.comp f', cg * cf, lief.trans lieg],
--   exact ‚ü®has_fderiv_at.comp x hg‚ÇÅ hf‚ÇÅ, 
--         mul_ne_zero hg‚ÇÇ hf‚ÇÇ, 
--         by ext; rw [continuous_linear_map.coe_comp' f' g', hf‚ÇÉ, hg‚ÇÉ]; 
--         simp; exact smul_smul cg cf _‚ü©,
-- end

-- theorem conformal.comp {f : X ‚Üí Y} {g : Y ‚Üí Z} (hf : conformal ùïú f) (hg : conformal ùïú g) :
-- conformal ùïú (g ‚àò f) := Œª x, conformal_at.comp (hf x) (hg (f x))

-- theorem conformal_at_iff {f : X ‚Üí Y} {x : X} {f' : X ‚âÉL[‚Ñù] Y}
-- (h : has_fderiv_at f f'.to_continuous_linear_map x) :
-- conformal_at ùïú f x ‚Üî ‚àÉ (c : ‚Ñù) (hc : c > 0), ‚àÄ (u v : X), inner (f' u) (f' v) = (c : ùïú) * (inner u v) :=
-- begin
--   split,
--   {
--     sorry,
--     -- intros h',
--     -- rcases h' with ‚ü®f‚ÇÅ, c‚ÇÅ, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©,
--     -- use [is_R_or_C.norm_sq c‚ÇÅ, is_R_or_C.norm_sq_pos.mpr h‚ÇÇ],
--     -- intros u v,
--     -- rw [‚Üê continuous_linear_equiv.coe_coe f', ‚Üê continuous_linear_equiv.coe_def_rev f'],
--     -- rw [has_fderiv_at.unique h h‚ÇÅ, h‚ÇÉ],
--     -- simp only [function.comp_apply, inner_smul_left, inner_smul_right, 
--     --            linear_isometry_equiv.inner_map_map],
--     -- rw ‚Üê mul_assoc, nth_rewrite 1 mul_comm, rw is_R_or_C.conj_mul_eq_norm_sq_left,
--   },
--   {
--     intros H,
--     rcases H with ‚ü®c‚ÇÅ, hc‚ÇÅ, huv‚ü©,
--     have hc‚ÇÅ' : ¬¨ (c‚ÇÅ : ùïú) = 0 := Œª w, (ne_of_gt hc‚ÇÅ) (is_R_or_C.of_real_eq_zero.mp w),
--     let c := real.sqrt c‚ÇÅ‚Åª¬π,
--     have hc : ¬¨ c = 0 := Œª w, by simp only [c] at w; exact (real.sqrt_ne_zero'.mpr $ inv_pos.mpr hc‚ÇÅ) w,
--     have hc' : c ‚Ä¢ c ‚Ä¢ (c‚ÇÅ : ùïú)= 1 := by 
--       repeat {rw [is_R_or_C.of_real_smul, 
--                 ‚Üê is_R_or_C.of_real_mul]}; simp only [c];
--       rw [‚Üê mul_assoc, real.mul_self_sqrt $ le_of_lt $ inv_pos.mpr hc‚ÇÅ, 
--             inv_mul_cancel $ ne_of_gt hc‚ÇÅ];
--       exact is_R_or_C.of_real_one,
--     let c_map := linear_equiv.smul_of_ne_zero ‚Ñù Y c hc,
--     let f‚ÇÅ := f'.to_linear_equiv.trans c_map,
--     have : (Œª (y : Y), (c : ùïú) ‚Ä¢ y) = (Œª (y : Y), c ‚Ä¢ y) := by ext; rw [is_R_or_C.of_real_alg, smul_assoc, one_smul],
--     have minor : ‚áëf‚ÇÅ = (Œª (y : Y), (c : ùïú) ‚Ä¢ y) ‚àò f' := by rw this; refl,
--     have minor' : ‚áëf' = (Œª (y : Y), c‚Åª¬π ‚Ä¢ y) ‚àò f‚ÇÅ := by ext; rw this at minor;
--       rw [minor, function.comp_apply, function.comp_apply, smul_smul, inv_mul_cancel hc, one_smul],
--     have key : ‚àÄ (u v : X), inner (f‚ÇÅ u) (f‚ÇÅ v) = inner u v := Œª u v, begin
--       rw [minor], simp_rw [function.comp_app], 
--       rw [inner_smul_real_left, inner_smul_real_right, 
--           huv u v, ‚Üê smul_mul_assoc, ‚Üê smul_mul_assoc],
--       rw hc', exact one_mul _,
--     end,
--     -- haveI restr_to_real : inner_product_space ‚Ñù X := inner_product_space.is_R_or_C_to_real ùïú X,
--     -- haveI restr_to_real' : inner_product_space ‚Ñù Y := inner_product_space.is_R_or_C_to_real ùïú Y,
--     let f‚ÇÇ : X ‚âÉ‚Çó·µ¢[‚Ñù] Y := ‚ü®f‚ÇÅ, Œª x, by simp only [norm_eq_sqrt_inner, key]‚ü©,
--     use [f'.to_continuous_linear_map, (c : ùïú)‚Åª¬π, f‚ÇÇ],
--     -- exact ‚ü®h, inv_ne_zero hc, minor'‚ü©,
--   },
-- end

-- def conformal_at.char_fun {f : X ‚Üí Y} (x : X) {f' : X ‚âÉL[‚Ñù] Y}
-- (h : has_fderiv_at f f'.to_continuous_linear_map x) (H : conformal_at ùïú f x) : ‚Ñù :=
-- by choose c hc huv using (conformal_at_iff h).mp H; exact c

-- def inner_product_angle {E : Type*} [inner_product_space ùïú E] (u v : E) : ùïú :=
-- inner u v / (‚à•u‚à• * ‚à•v‚à•)
-- @[simp] theorem inner_product_angle.def {E : Type*} [inner_product_space ùïú E] (u v : E) :
-- inner_product_angle u v = (inner u v / (‚à•u‚à• * ‚à•v‚à•) : ùïú) := rfl

-- theorem conformal_at_preserves_angle {f : X ‚Üí Y} {x : X} {f' : X ‚âÉL[ùïú] Y}
-- (h : has_fderiv_at f f'.to_continuous_linear_map x) (H : conformal_at ùïú f x) :
-- ‚àÄ (u v : X), inner_product_angle (f' u) (f' v) = (inner_product_angle u v : ùïú) :=
-- begin
--   intros u v, 
--   rcases H with ‚ü®f‚ÇÅ, c‚ÇÅ, lie, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©,
--   have minor : ¬¨ ‚à•c‚ÇÅ‚à• = 0 := Œª w, h‚ÇÇ (norm_eq_zero.mp w),
--   have minor' : ¬¨ (‚à•c‚ÇÅ‚à• : ùïú) = 0 := Œª w, minor (is_R_or_C.of_real_eq_zero.mp w),
--   have : f'.to_continuous_linear_map = f‚ÇÅ := has_fderiv_at.unique h h‚ÇÅ,
--   rw [‚Üê continuous_linear_equiv.coe_coe f', ‚Üê continuous_linear_equiv.coe_def_rev f'],
--   repeat {rw inner_product_angle.def},
--   rw [this, h‚ÇÉ],
--   repeat {rw function.comp_apply},
--   rw [inner_smul_left, inner_smul_right, ‚Üê mul_assoc, 
--       linear_isometry_equiv.inner_map_map, is_R_or_C.conj_mul_eq_norm_sq_left],
--   repeat {rw [norm_smul, linear_isometry_equiv.norm_map]},
--   rw [is_R_or_C.norm_sq_eq_def', ‚Üê is_R_or_C.of_real_mul, ‚Üê mul_assoc],
--   nth_rewrite 2 mul_comm,
--   rw [‚Üê mul_assoc, pow_two],
--   repeat {rw [is_R_or_C.of_real_mul, mul_assoc]},
--   repeat {rw mul_div_mul_left _ _ minor'},
-- end

-- variables {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ}

-- -- This is a baby version of the Jacobian of a real differentiable complex function

-- def complex_jacobian_at (h : differentiable_at ‚Ñù f z) : matrix (fin 2) (fin 2) ‚Ñù :=
-- ![![fderiv ‚Ñù (re ‚àò f) z 1, fderiv ‚Ñù (re ‚àò f) z I], ![fderiv ‚Ñù (im ‚àò f) z 1, fderiv ‚Ñù (im ‚àò f) z I]]

-- @[simp] theorem complex_jacobian_at.def (h : differentiable_at ‚Ñù f z) :
-- complex_jacobian_at h = ![![fderiv ‚Ñù (re ‚àò f) z 1, fderiv ‚Ñù (re ‚àò f) z I], 
--                           ![fderiv ‚Ñù (im ‚àò f) z 1, fderiv ‚Ñù (im ‚àò f) z I]] := rfl

-- def complex_jacobian_det_at (h : differentiable_at ‚Ñù f z) : ‚Ñù :=
-- (fderiv ‚Ñù (re ‚àò f) z 1) * fderiv ‚Ñù (im ‚àò f) z I - (fderiv ‚Ñù (re ‚àò f) z I) * fderiv ‚Ñù (im ‚àò f) z 1

-- variables (h : differentiable_at ‚Ñù f z)

-- @[simp] theorem complex_jacobian_at_det_eq (h : differentiable_at ‚Ñù f z) :
-- (complex_jacobian_at h).det = (fderiv ‚Ñù (re ‚àò f) z 1) * fderiv ‚Ñù (im ‚àò f) z I - (fderiv ‚Ñù (re ‚àò f) z I) * fderiv ‚Ñù (im ‚àò f) z 1 :=
-- begin
--   rw matrix.det_succ_row_zero, repeat {rw [fin.sum_univ_succ]}, simp_rw [fin.sum_univ_zero],
--   simp, rw ‚Üê sub_eq_add_neg _ _,
-- end

-- @[simp] theorem cmatrix_two_apply00 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 0 0 = a := rfl
-- @[simp] theorem cmatrix_two_apply01 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 0 1 = b := rfl
-- @[simp] theorem cmatrix_two_apply10 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 1 0 = c := rfl
-- @[simp] theorem cmatrix_two_apply11 (a b c d : ‚ÑÇ) : ![![a, b], ![c, d]] 1 1 = d := rfl
-- @[simp] theorem rmatrix_two_apply00 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 0 0 = a := rfl
-- @[simp] theorem rmatrix_two_apply01 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 0 1 = b := rfl
-- @[simp] theorem rmatrix_two_apply10 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 1 0 = c := rfl
-- @[simp] theorem rmatrix_two_apply11 (a b c d : ‚Ñù) : ![![a, b], ![c, d]] 1 1 = d := rfl

-- @[simp] theorem cvec_two_apply (a b : ‚ÑÇ) : ![a, b] 0 = a := rfl
-- @[simp] theorem cvec_two_apply' (a b : ‚ÑÇ) : ![a, b] 1 = b := rfl
-- @[simp] theorem rvec_two_apply (a b : ‚Ñù) : ![a, b] 0 = a := rfl
-- @[simp] theorem rvec_two_apply' (a b : ‚Ñù) : ![a, b] 1 = b := rfl

-- theorem real_fderiv_to_matrix (h : differentiable_at ‚Ñù f z) (x : ‚ÑÇ) : 
-- (linear_map.to_matrix complex.basis_one_I complex.basis_one_I) (fderiv ‚Ñù f z) = complex_jacobian_at h :=
-- begin
--   let h' := h.restrict_scalars ‚Ñù,
--   ext,
--   rw linear_map.to_matrix_apply _ _ _ _ _,
--   simp only [coe_basis_one_I, coe_basis_one_I_repr],
--   fin_cases i,
--   { 
--     fin_cases j,
--     repeat {rw cvec_two_apply}, rw rvec_two_apply, 
--     simp only [complex_jacobian_at, rmatrix_two_apply00],
--     sorry,
--   },
--   { sorry, },
-- end

-- theorem complex_jacobian_det_eq_fderiv_norm_sq (h : differentiable_at ‚Ñù f z) :
-- complex_jacobian_det_at h = norm_sq (fderiv ‚ÑÇ f z 1) :=
-- begin
--   sorry,
-- end

-- @[simp] theorem complex_jacobian_det_eq_zero_iff (h : differentiable_at ‚Ñù f z) :
-- complex_jacobian_det_at h = 0 ‚Üî fderiv ‚ÑÇ f z 1 = 0 := by rw complex_jacobian_det_eq_fderiv_norm_sq h; simp

-- @[simp] theorem complex_jacobian_det_ne_zero_iff (h : differentiable_at ‚Ñù f z) :
-- ¬¨ complex_jacobian_det_at h = 0 ‚Üî ¬¨ fderiv ‚ÑÇ f z 1 = 0 := not_iff_not_of_iff $ complex_jacobian_det_eq_zero_iff h

-- theorem conformal_at_iff_holomorph_deriv_ne_zero
-- {f : ‚ÑÇ ‚Üí ‚ÑÇ} {z : ‚ÑÇ} (h : differentiable_at ‚Ñù f z) :
-- ¬¨ deriv f z = 0 ‚Üî conformal_at ‚Ñù f z :=
-- begin
--   split,
--   {

--   },
--   sorry,
-- end

