import analysis.calculus.conformal
import similarity
import data.matrix.notation
import analysis.calculus.times_cont_diff
import analysis.calculus.fderiv_symmetric

noncomputable theory

open conformal_at submodule set
open_locale classical real_inner_product_space

section linear_alg_prep

variables {E F : Type*} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {x : E}

lemma A {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {x : E} 
  (h : ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™f' x u, f' x v‚ü´ = c * ‚ü™u, v‚ü´) {u v : E} :
  ‚ü™u, v‚ü´ = 0 ‚Üî ‚ü™f' x u, f' x v‚ü´ = 0 :=
begin
  rcases h with ‚ü®c, p, q‚ü©,
  split,
  { intros huv,
    convert q u v,
    rw [huv, mul_zero] },
  { intros huv,
    rw q u v at huv,
    exact eq_zero_of_ne_zero_of_mul_left_eq_zero (ne_of_gt p) huv } 
end

lemma A' {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {u v : E} (huv : ‚ü™u, v‚ü´ = 0)
  (h : ‚àÄ x, ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™f' x u, f' x v‚ü´ = c * ‚ü™u, v‚ü´) :
  (Œª x, ‚ü™f' x u, f' x v‚ü´) = Œª x, (0 : ‚Ñù) :=
by {ext1, rwa ‚Üê A (h x) }

lemma B {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {x : E} {K : submodule ‚Ñù E} (hf : function.surjective (f' x))
  (h : ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™f' x u, f' x v‚ü´ = c * ‚ü™u, v‚ü´) :
  (K·óÆ).map (f' x : E ‚Üí‚Çó[‚Ñù] F) = (K.map (f' x))·óÆ :=
begin
  ext1 y'',
  simp only [mem_map, mem_orthogonal],
  split,
  { rintros ‚ü®u, hu, huy‚ü©,
    intros v hv,
    rcases hv with ‚ü®z, hz, hzv‚ü©,
    rw [‚Üê huy, ‚Üê hzv, continuous_linear_map.coe_coe, ‚Üê A h],
    exact hu z hz },
  { intros H,
    rcases hf y'' with ‚ü®y', hy'‚ü©,
    refine ‚ü®y', Œª u hu, _, hy'‚ü©,
    rw [A h, hy'],
    exact H (f' x u) ‚ü®u, hu, rfl‚ü© }
end

lemma C {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {x : E} (hf : function.surjective (f' x))
  (h : ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™f' x u, f' x v‚ü´ = c * ‚ü™u, v‚ü´) {u v : E} {w : F}
  (H : ‚àÄ (t : E), t ‚àà (span ‚Ñù ({u} ‚à™ {v} : set E))·óÆ ‚Üí ‚ü™w, f' x t‚ü´ = 0) :
  w ‚àà (span ‚Ñù ({f' x u} ‚à™ {f' x v} : set F)) :=
begin
  have triv‚ÇÅ : {f' x u} ‚à™ {f' x v} = f' x '' ({u} ‚à™ {v}) :=
    by simp only [image_union, image_singleton],
  rw [triv‚ÇÅ, ‚Üê continuous_linear_map.coe_coe, ‚Üê map_span],
  have triv‚ÇÇ : is_complete (span ‚Ñù ({u} ‚à™ {v} : set E) : set E),
  { haveI : finite_dimensional ‚Ñù (span ‚Ñù ({u} ‚à™ {v} : set E)) :=
      finite_dimensional.span_of_finite ‚Ñù ((finite_singleton _).union $ finite_singleton _),
    exact complete_of_finite_dimensional _ },
  haveI : complete_space (span ‚Ñù ({u} ‚à™ {v} : set E)) := triv‚ÇÇ.complete_space_coe,
  rw [‚Üê orthogonal_orthogonal (span ‚Ñù ({u} ‚à™ {v} : set E)), B hf h, mem_orthogonal],
  intros y hy,
  rw [mem_map] at hy,
  rcases hy with ‚ü®y', hy', Hy'‚ü©,
  rw [real_inner_comm, ‚Üê Hy'],
  exact H y' hy'
end

end linear_alg_prep

section tot_diff_eq
open continuous_linear_map_eval_at
open_locale topological_space

variables {E F : Type*} [inner_product_space ‚Ñù E] [inner_product_space ‚Ñù F] {f : E ‚Üí F}

lemma D21 {y : E} {n : ‚Ñï} (hf : times_cont_diff_at ‚Ñù (n + 1) f y) :
  ‚àÄ·∂† (x : E) in ùìù y, has_fderiv_at f (fderiv ‚Ñù f x) x :=
begin
  rcases times_cont_diff_at_succ_iff_has_fderiv_at.mp hf with ‚ü®f', ‚ü®s, hs, hxs‚ü©, hf'‚ü©,
  have minor‚ÇÅ : ‚àÄ (x : E), x ‚àà s ‚Üí differentiable_at ‚Ñù f x := Œª x hx, ‚ü®f' x, hxs x hx‚ü©,
  have minor‚ÇÇ : ‚àÄ (x : E), x ‚àà s ‚Üí has_fderiv_at f (fderiv ‚Ñù f x) x := 
    Œª x hx, (minor‚ÇÅ x hx).has_fderiv_at,
  rw filter.eventually_iff_exists_mem,
  exact ‚ü®s, hs, minor‚ÇÇ‚ü©
end

lemma D22 {y : E} {n : ‚Ñï} (hf : times_cont_diff_at ‚Ñù (n + 1) f y) :
  times_cont_diff_at ‚Ñù n (fderiv ‚Ñù f) y :=
begin
  have triv‚ÇÅ : (n : with_top ‚Ñï) ‚â§ n + 1 := 
    by { apply with_top.coe_le_coe.mpr, exact nat.le_succ _ },
  have triv‚ÇÇ : (1 : with_top ‚Ñï) ‚â§ n + 1 := 
    by { apply with_top.coe_le_coe.mpr, linarith },
  rcases times_cont_diff_at_succ_iff_has_fderiv_at.mp hf with ‚ü®f', ‚ü®s, hs, hxs‚ü©, hf'‚ü©,
  have minor‚ÇÅ : ‚àÄ (x : E), x ‚àà s ‚Üí differentiable_at ‚Ñù f x := Œª x hx, ‚ü®f' x, hxs x hx‚ü©,
  have minor‚ÇÇ : set.eq_on (fderiv ‚Ñù f) f' s,
  { intros x hxmem,
    have := (hf.differentiable_at triv‚ÇÇ).has_fderiv_at,
    exact (minor‚ÇÅ x hxmem).has_fderiv_at.unique (hxs x hxmem) },
  exact hf'.congr_of_eventually_eq (filter.eventually_eq_of_mem hs minor‚ÇÇ)
end

lemma D23 {y : E} {n : ‚Ñï} (hn : 0 < n) (hf : times_cont_diff_at ‚Ñù (n + 1) f y) :
  differentiable_at ‚Ñù (fderiv ‚Ñù f) y :=
(D22 hf).differentiable_at (with_top.coe_le_coe.mpr $ nat.succ_le_of_lt hn)

lemma DD1 {f' : E ‚Üí (E ‚ÜíL[‚Ñù] F)} {y u : E} (hf : ‚àÄ·∂† (x : E) in ùìù y, has_fderiv_at f (f' x) x)
  (hf' : differentiable_at ‚Ñù f' y) :
  fderiv ‚Ñù (Œª x, f' x u) y = fderiv ‚Ñù f' y u :=
begin
  have : (Œª x, f' x u) = Œª x, ((continuous_linear_map_eval_at ‚Ñù F u) ‚àò f') x :=
    by simp only [function.comp_app, continuous_linear_map_eval_at_apply],
  simp only [this, congr_arg],
  rw fderiv.comp _ ((times_cont_diff_top ‚Ñù F u).differentiable le_top).differentiable_at hf',
  rw (is_bounded_linear_eval_at ‚Ñù F u).fderiv,
  ext1 v,
  simp only [continuous_linear_map.coe_comp', function.comp_app, 
             continuous_linear_map_eval_at_apply],
  rw [‚Üê continuous_linear_map.coe_coe, coe_eval_at, continuous_linear_map_eval_at_apply],
  exact second_derivative_symmetric_of_eventually hf hf'.has_fderiv_at _ _
end

lemma DD2 {y : E} {n : ‚Ñï} (hn : 0 < n) (hf : times_cont_diff_at ‚Ñù (n + 1) f y) (u : E) :
  differentiable_at ‚Ñù (Œª x, fderiv ‚Ñù f x u) y :=
begin
  have : (Œª x, fderiv ‚Ñù f x u) = Œª x, ((continuous_linear_map_eval_at ‚Ñù F u) ‚àò fderiv ‚Ñù f) x :=
    by simp only [function.comp_app, continuous_linear_map_eval_at_apply],
  rw [this],
  simp only [congr_arg],
  apply differentiable_at.comp,
  { refine (times_cont_diff.differentiable _ le_top).differentiable_at,
    exact times_cont_diff_top _ _ _ },
  { exact D23 hn hf }
end

lemma D' (u v w : E) {y : E} {n : ‚Ñï} (hn : 0 < n) (hf : times_cont_diff_at ‚Ñù (n + 1) f y)  :
  fderiv ‚Ñù (Œª x, ‚ü™fderiv ‚Ñù f x u, fderiv ‚Ñù f x v‚ü´) y w = 
  ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) y u w, fderiv ‚Ñù f y v‚ü´ + 
  ‚ü™fderiv ‚Ñù f y u, fderiv ‚Ñù (fderiv ‚Ñù f) y v w‚ü´ :=
begin
  rw [fderiv_inner_apply (DD2 hn hf _) (DD2 hn hf _)],
  simp only [congr_arg, DD1 (D21 hf) (D23 hn hf), congr_arg, add_comm]
end

lemma D {x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) {u v w : E} :
  ‚ü™u, v‚ü´ = 0 ‚Üí ‚ü™w, u‚ü´ = 0 ‚Üí ‚ü™w, v‚ü´ = 0 ‚Üí ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) x u v, fderiv ‚Ñù f x w‚ü´ = 0 :=
Œª huv hwu hwv, begin
  rw real_inner_comm at hwv,
  have m‚ÇÅ := D' u v w zero_lt_one hf',
  have m‚ÇÇ := D' v w u zero_lt_one hf',
  have m‚ÇÉ := D' w u v zero_lt_one hf',
  have triv‚ÇÅ :  ‚àÄ x, ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™fderiv ‚Ñù f x u, fderiv ‚Ñù f x v‚ü´ = c * ‚ü™u, v‚ü´ :=
  Œª x, conformal_at_iff'.mp (hf.conformal_at x),
  rw [A' huv triv‚ÇÅ] at m‚ÇÅ,
  rw [A' hwv triv‚ÇÅ] at m‚ÇÇ,
  rw [A' hwu triv‚ÇÅ] at m‚ÇÉ,
  rw [fderiv_const, pi.zero_apply, continuous_linear_map.zero_apply] at m‚ÇÅ m‚ÇÇ m‚ÇÉ,
  rw add_comm at m‚ÇÅ m‚ÇÉ,
  nth_rewrite 0 real_inner_comm at m‚ÇÉ m‚ÇÅ,
  nth_rewrite 1 real_inner_comm at m‚ÇÅ,
  rw [second_derivative_symmetric_of_eventually (D21 hf') (D23 zero_lt_one hf').has_fderiv_at v u,
      second_derivative_symmetric_of_eventually (D21 hf') (D23 zero_lt_one hf').has_fderiv_at w u] 
      at m‚ÇÇ,
  rw [second_derivative_symmetric_of_eventually (D21 hf') (D23 zero_lt_one hf').has_fderiv_at w v] 
      at m‚ÇÉ,
  have triv‚ÇÇ : ‚àÄ {a b c : ‚Ñù}, a + b = 0 ‚Üí b + c = 0 ‚Üí a + c = 0 ‚Üí a = 0 :=
  Œª a b c hab hbc hac, begin
    rw [‚Üê hab, ‚Üê zero_add (a + b), ‚Üê hac, ‚Üê add_assoc, ‚Üê zero_add (b + c)] at hbc,
    nth_rewrite 3 add_comm at hbc,
    rw [add_assoc, add_assoc] at hbc,
    nth_rewrite 1 ‚Üê add_assoc at hbc,
    nth_rewrite 4 add_comm at hbc,
    exact (add_self_eq_zero.mp $ add_right_cancel hbc.symm)
  end,
  exact triv‚ÇÇ m‚ÇÉ.symm m‚ÇÅ.symm m‚ÇÇ.symm
end

lemma G'' {x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) 
  (h : function.surjective (fderiv ‚Ñù f x)) {u v : E} (huv : ‚ü™u, v‚ü´ = 0) :
  fderiv ‚Ñù (fderiv ‚Ñù f) x u v ‚àà span ‚Ñù ({fderiv ‚Ñù f x u} ‚à™ {fderiv ‚Ñù f x v} : set F) := 
begin
  refine C h (conformal_at_iff'.mp $ hf.conformal_at _) (Œª t ht, _),
  rw mem_orthogonal at ht,
  have triv‚ÇÅ : u ‚àà span ‚Ñù ({u} ‚à™ {v} : set E) := subset_span (or.intro_left _ $ mem_singleton _),
  have triv‚ÇÇ : v ‚àà span ‚Ñù ({u} ‚à™ {v} : set E) := subset_span (or.intro_right _ $ mem_singleton _),
  have minor‚ÇÅ := ht u triv‚ÇÅ,
  have minor‚ÇÇ := ht v triv‚ÇÇ,
  rw real_inner_comm at minor‚ÇÅ minor‚ÇÇ,
  exact D hf hf' huv minor‚ÇÅ minor‚ÇÇ
end

lemma G' {x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) 
  (h : function.surjective (fderiv ‚Ñù f x)) {u v : E} (huv : ‚ü™u, v‚ü´ = 0) : 
  fderiv ‚Ñù (fderiv ‚Ñù f) x u v = 
  (‚ü™fderiv ‚Ñù f x u, fderiv ‚Ñù (fderiv ‚Ñù f) x u v‚ü´ / ‚Üë‚à•fderiv ‚Ñù f x u‚à• ^ 2) ‚Ä¢ fderiv ‚Ñù f x u +
  (‚ü™fderiv ‚Ñù f x v, fderiv ‚Ñù (fderiv ‚Ñù f) x u v‚ü´ / ‚Üë‚à•fderiv ‚Ñù f x v‚à• ^ 2) ‚Ä¢ fderiv ‚Ñù f x v :=
begin
  rw [‚Üê orthogonal_projection_singleton, ‚Üê orthogonal_projection_singleton],
  have := G'' hf hf' h huv,
  rw [span_union, mem_sup] at this,
  rcases this with ‚ü®p‚ÇÅ, hp‚ÇÅ, p‚ÇÇ, hp‚ÇÇ, hp‚ÇÅp‚ÇÇ‚ü©,
  have triv‚ÇÅ : fderiv ‚Ñù (fderiv ‚Ñù f) x u v - p‚ÇÇ = p‚ÇÅ := 
    by rw [‚Üê hp‚ÇÅp‚ÇÇ, ‚Üê add_sub, sub_self, add_zero],
  have triv‚ÇÇ : fderiv ‚Ñù (fderiv ‚Ñù f) x u v - p‚ÇÅ = p‚ÇÇ := 
    by { rw [‚Üê hp‚ÇÅp‚ÇÇ, add_comm], rw [‚Üê add_sub, sub_self, add_zero] },
  rcases mem_span_singleton.mp hp‚ÇÅ with ‚ü®s‚ÇÅ, hs‚ÇÅ‚ü©,
  rcases mem_span_singleton.mp hp‚ÇÇ with ‚ü®s‚ÇÇ, hs‚ÇÇ‚ü©,
  have key‚ÇÅ : ‚àÄ (w : F), w ‚àà  span ‚Ñù ({fderiv ‚Ñù f x u} : set F) ‚Üí
    ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) x u v - p‚ÇÅ, w‚ü´ = 0 :=
  Œª w hw, begin
    rcases mem_span_singleton.mp hw with ‚ü®s, hs‚ü©,
    rw [‚Üê hs, triv‚ÇÇ, ‚Üê hs‚ÇÇ, real_inner_smul_left, real_inner_smul_right],
    rw [real_inner_comm, A (conformal_at_iff'.mp $ hf.conformal_at x)] at huv,
    rw [huv, mul_zero, mul_zero]
  end,
  have key‚ÇÇ : ‚àÄ (w : F), w ‚àà  span ‚Ñù ({fderiv ‚Ñù f x v} : set F) ‚Üí
    ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) x u v - p‚ÇÇ, w‚ü´ = 0 :=
  Œª w hw, begin
    rcases mem_span_singleton.mp hw with ‚ü®s, hs‚ü©,
    rw [‚Üê hs, triv‚ÇÅ, ‚Üê hs‚ÇÅ, real_inner_smul_left, real_inner_smul_right],
    rw [A (conformal_at_iff'.mp $ hf.conformal_at x)] at huv,
    rw [huv, mul_zero, mul_zero]
  end,
  rw [eq_orthogonal_projection_of_mem_of_inner_eq_zero hp‚ÇÅ key‚ÇÅ, 
      eq_orthogonal_projection_of_mem_of_inner_eq_zero hp‚ÇÇ key‚ÇÇ],
  exact hp‚ÇÅp‚ÇÇ.symm
end

lemma G {x' : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x') {u : E} (v : E) 
  (hu : u ‚â† 0) : ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) x' u v, fderiv ‚Ñù f x' u‚ü´ + 
  ‚ü™fderiv ‚Ñù f x' u, fderiv ‚Ñù (fderiv ‚Ñù f) x' u v‚ü´ =
  2 * (similarity_factor_sqrt (conformal_at_iff'.mp $ hf.conformal_at x') * (fderiv ‚Ñù 
  (Œª y, similarity_factor_sqrt $ conformal_at_iff'.mp $ hf.conformal_at y) x' v) * ‚ü™u, u‚ü´) :=
begin
  rw ‚Üê D' u u v zero_lt_one hf',
  have : (Œª (y : E), ‚ü™fderiv ‚Ñù f y u, fderiv ‚Ñù f y u‚ü´) = 
    (Œª y, ‚ü™u, u‚ü´ * id y) ‚àò (Œª y, similarity_factor $ conformal_at_iff'.mp $ hf.conformal_at y),
  { ext1 y,
    simp only [function.comp_app, congr_arg],
    rw mul_comm,
    exact (similarity_factor_prop $ conformal_at_iff'.mp $ hf.conformal_at y).2 u u },
  have minor‚ÇÅ := Œª y, conformal_at_iff'.mp $ hf.conformal_at y,
  have minor‚ÇÇ := (similarity_factor_times_cont_diff_at hu x' minor‚ÇÅ $ D22 hf').differentiable_at 
    (le_of_eq rfl),
  have minor‚ÇÉ := (similarity_factor_sqrt_times_cont_diff_at hu x' minor‚ÇÅ 
    $ D22 hf').differentiable_at (le_of_eq rfl),
  rw [this, fderiv.comp _ (differentiable_at_id.const_mul _) minor‚ÇÇ, 
      fderiv_const_mul differentiable_at_id ‚ü™u, u‚ü´, fderiv_id],
  rw ‚Üê similarity_factor_sqrt_eq minor‚ÇÅ,
  simp only [pow_two], 
  rw [fderiv_mul minor‚ÇÉ minor‚ÇÉ, continuous_linear_map.coe_comp'],
  simp only [function.comp_app, continuous_linear_map.coe_add', pi.add_apply, 
             continuous_linear_map.smul_apply, smul_eq_mul, continuous_linear_map.coe_id'],
  simp only [id],
  ring
end

lemma GG' {x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) {u : E} (v : E) 
  (hu : u ‚â† 0) : ‚ü™fderiv ‚Ñù (fderiv ‚Ñù f) x u v, fderiv ‚Ñù f x u‚ü´ / ‚ü™u, u‚ü´ = 
  similarity_factor_sqrt (conformal_at_iff'.mp $ hf.conformal_at x) * (fderiv ‚Ñù 
  (Œª y, similarity_factor_sqrt $ conformal_at_iff'.mp $ hf.conformal_at y) x v) :=
begin
  have key := G hf hf' v hu,
  rw [real_inner_comm, ‚Üê two_mul, real_inner_comm] at key,
  have triv : ‚ü™u, u‚ü´ ‚â† 0 := Œª W, hu (inner_self_eq_zero.mp W),
  rw div_eq_iff_mul_eq triv,
  refine (mul_left_cancel' _ key).symm,
  exact two_ne_zero  
end

lemma GG1 {u x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) (v : E) 
  (hu : u ‚â† 0) : ‚ü™fderiv ‚Ñù f x u, fderiv ‚Ñù (fderiv ‚Ñù f) x u v‚ü´ / ‚à•fderiv ‚Ñù f x u‚à• ^ 2 =
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt $ conformal_at_iff'.mp $ hf.conformal_at y) x v) *
  similarity_factor_sqrt_inv (conformal_at_iff'.mp $ hf.conformal_at x) :=
begin
  rw [pow_two, ‚Üê real_inner_self_eq_norm_sq],
  have triv‚ÇÅ : ‚ü™u, u‚ü´ ‚â† 0 := Œª W, hu (inner_self_eq_zero.mp W),
  rw [‚Üê div_mul_div_cancel _ triv‚ÇÅ,
      (similarity_factor_sqrt_inv_prop $ conformal_at_iff'.mp $ hf.conformal_at x).2,
      real_inner_comm, GG' hf hf' v hu],
  simp only [similarity_factor_sqrt_inv, inv_inv'],
  field_simp [triv‚ÇÅ, (similarity_factor_sqrt_prop $ conformal_at_iff'.mp $ hf.conformal_at x).1],
  ring
end

lemma GG2 {v x : E} (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) (u : E) 
  (hv : v ‚â† 0) : ‚ü™fderiv ‚Ñù f x v, fderiv ‚Ñù (fderiv ‚Ñù f) x u v‚ü´ / ‚à•fderiv ‚Ñù f x v‚à• ^ 2 =
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt $ conformal_at_iff'.mp $ hf.conformal_at y) x u) *
  similarity_factor_sqrt_inv (conformal_at_iff'.mp $ hf.conformal_at x) :=
begin
  rw second_derivative_symmetric_of_eventually (D21 hf') (D23 zero_lt_one hf').has_fderiv_at u v,
  exact GG1 hf hf' u hv
end

lemma GGG {u v x : E} (hu : u ‚â† 0) (hv : v ‚â† 0) (huv : ‚ü™u, v‚ü´ = 0)
  (hf : conformal f) (hf' : times_cont_diff_at ‚Ñù 2 f x) (h : function.surjective (fderiv ‚Ñù f x)): 
  (similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at x) ‚Ä¢ 
  (fderiv ‚Ñù (fderiv ‚Ñù f) x u v) +
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at y) x v) ‚Ä¢
  fderiv ‚Ñù f x u + 
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at y) x u) ‚Ä¢
  fderiv ‚Ñù f x v = 0 :=
begin
  have minor‚ÇÅ := D22 hf',
  have Q : ‚àÄ y, ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, ‚ü™fderiv ‚Ñù f y u, fderiv ‚Ñù f y v‚ü´ = c * ‚ü™u, v‚ü´ :=
    Œª y, conformal_at_iff'.mp $ hf.conformal_at y,
  have P := Q x,
  have key := similarity_factor_sqrt_inv_fderiv hv x Q zero_lt_one minor‚ÇÅ,
  rw [G' hf hf' h huv, key],
  simp only [is_R_or_C.coe_real_eq_id, id],
  rw [GG1 hf hf' v hu, GG2 hf hf' u hv], 
  simp only [smul_add, smul_smul, pi.neg_apply, pi.mul_apply, congr_arg],
  rw [‚Üê similarity_factor_sqrt_inv_eq' Q, inv_pow', inv_inv', pow_two],
  nth_rewrite 1 add_comm,
  simp only [‚Üê add_assoc, ‚Üê add_smul, add_assoc, ‚Üê add_smul],
  rw [neg_mul_eq_neg_mul_symm, neg_add_eq_sub],
  simp only [mul_assoc, mul_comm, sub_self, zero_smul],
  simp only [mul_assoc, mul_neg_eq_neg_mul_symm, 
             add_comm, neg_add_eq_sub, mul_comm, sub_self, zero_smul, zero_add]
end

open_locale filter

lemma GGG_eventually_eq {u v x‚ÇÄ : E} {s : set E} (hx‚ÇÄs : x‚ÇÄ ‚àà s) 
  (hs : is_open s) (hu : u ‚â† 0) (hv : v ‚â† 0) (huv : ‚ü™u, v‚ü´ = 0) (hf : conformal f) 
  (hf' : ‚àÄ y ‚àà s, times_cont_diff_at ‚Ñù 2 f y) (h : ‚àÄ y ‚àà s, function.surjective (fderiv ‚Ñù f y)) : 
  (Œª x, (similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at x) ‚Ä¢ 
  (fderiv ‚Ñù (fderiv ‚Ñù f) x u v) +
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at y) x v) ‚Ä¢
  fderiv ‚Ñù f x u + 
  (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp $ hf.conformal_at y) x u) ‚Ä¢
  fderiv ‚Ñù f x v) =·∂†[ùìù x‚ÇÄ] (Œª x, 0) :=
filter.eventually_eq_of_mem (hs.mem_nhds hx‚ÇÄs) (Œª y hy, GGG hu hv huv hf (hf' y hy) $ h y hy)

lemma J1 {u v w x‚ÇÄ : E} (hw : w ‚â† 0) {s : set E} (hx‚ÇÄs : x‚ÇÄ ‚àà s) 
  (hs : is_open s) (hu : u ‚â† 0) (hv : v ‚â† 0) (huv : ‚ü™u, v‚ü´ = 0) (hf : conformal f) 
  (hf' : ‚àÄ y ‚àà s, times_cont_diff_at ‚Ñù 3 f y) (h : ‚àÄ y ‚àà s, function.surjective (fderiv ‚Ñù f y)) :
  fderiv ‚Ñù (Œª x, (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp 
  $ hf.conformal_at y) x v) ‚Ä¢ fderiv ‚Ñù f x u) x‚ÇÄ w = 
  fderiv ‚Ñù (fderiv ‚Ñù $ Œª y, similarity_factor_sqrt_inv $ 
  conformal_at_iff'.mp $ hf.conformal_at y) x‚ÇÄ w v ‚Ä¢ fderiv ‚Ñù f x‚ÇÄ u +
  fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp 
  $ hf.conformal_at y) x‚ÇÄ v ‚Ä¢ fderiv ‚Ñù (fderiv ‚Ñù f) x‚ÇÄ w u :=
begin
  have triv : (1 : with_top ‚Ñï) ‚â§ 3 := by { apply with_top.coe_le_coe.mpr, norm_num },
  have P : ‚àÄ (y : E), ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, 
    ‚ü™fderiv ‚Ñù f y u, fderiv ‚Ñù f y v‚ü´ = c * ‚ü™u, v‚ü´ := Œª y, conformal_at_iff'.mp $ hf.conformal_at y,
  have Q := similarity_factor_sqrt_inv_times_cont_diff_at hw x‚ÇÄ P (D22 $ hf' x‚ÇÄ hx‚ÇÄs),
  rw fderiv_smul,
  simp only [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, 
             continuous_linear_map.smul_right_apply, congr_arg],
  have minor‚ÇÅ : ‚àÄ·∂† (x : E) in ùìù x‚ÇÄ, has_fderiv_at f (fderiv ‚Ñù f x) x := 
    filter.eventually_of_mem (is_open.mem_nhds hs hx‚ÇÄs) 
    (Œª a ha, ((hf' a ha).differentiable_at triv).has_fderiv_at),
  have minor‚ÇÇ : differentiable_at ‚Ñù (fderiv ‚Ñù f) x‚ÇÄ := D23 zero_lt_two (hf' x‚ÇÄ hx‚ÇÄs),
  have minor‚ÇÉ : ‚àÄ·∂† (x : E) in ùìù x‚ÇÄ, has_fderiv_at (Œª (y : E), similarity_factor_sqrt_inv $ P y) 
    (fderiv ‚Ñù (Œª (y : E), similarity_factor_sqrt_inv $ P y) x) x :=
    filter.eventually_of_mem (is_open.mem_nhds hs hx‚ÇÄs)
    (Œª a ha, ((similarity_factor_sqrt_inv_times_cont_diff_at hw a P $ 
    D22 $ hf' a ha).differentiable_at $ with_top.coe_le_coe.mpr one_le_two).has_fderiv_at),
  have minor‚ÇÑ : differentiable_at ‚Ñù (fderiv ‚Ñù (Œª (y : E), similarity_factor_sqrt_inv $ P y)) x‚ÇÄ :=
    D23 zero_lt_one Q,
  rw [DD1 minor‚ÇÅ minor‚ÇÇ, DD1 minor‚ÇÉ minor‚ÇÑ], 
  simp only [congr_arg],
  rw [second_derivative_symmetric_of_eventually minor‚ÇÅ minor‚ÇÇ.has_fderiv_at,
      second_derivative_symmetric_of_eventually minor‚ÇÉ minor‚ÇÑ.has_fderiv_at, add_comm],
  exact DD2 zero_lt_one Q v,
  exact DD2 zero_lt_two (hf' x‚ÇÄ hx‚ÇÄs) u
end

lemma J2 {u v w x‚ÇÄ : E} (hw : w ‚â† 0) {s : set E} (hx‚ÇÄs : x‚ÇÄ ‚àà s) 
  (hs : is_open s) (hu : u ‚â† 0) (hv : v ‚â† 0) (huv : ‚ü™u, v‚ü´ = 0) (hf : conformal f) 
  (hf' : ‚àÄ y ‚àà s, times_cont_diff_at ‚Ñù 3 f y) (h : ‚àÄ y ‚àà s, function.surjective (fderiv ‚Ñù f y)) :
  fderiv ‚Ñù (Œª x, (fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp 
  $ hf.conformal_at y) x v) ‚Ä¢ fderiv ‚Ñù f x u) x‚ÇÄ w = 
  fderiv ‚Ñù (fderiv ‚Ñù $ Œª y, similarity_factor_sqrt_inv $ 
  conformal_at_iff'.mp $ hf.conformal_at y) x‚ÇÄ w v ‚Ä¢ fderiv ‚Ñù f x‚ÇÄ u +
  fderiv ‚Ñù (Œª y, similarity_factor_sqrt_inv $ conformal_at_iff'.mp 
  $ hf.conformal_at y) x‚ÇÄ v ‚Ä¢ fderiv ‚Ñù (fderiv ‚Ñù f) x‚ÇÄ w u :=
begin
  have triv : (1 : with_top ‚Ñï) ‚â§ 3 := by { apply with_top.coe_le_coe.mpr, norm_num },
  have P : ‚àÄ (y : E), ‚àÉ (c : ‚Ñù), 0 < c ‚àß ‚àÄ u v, 
    ‚ü™fderiv ‚Ñù f y u, fderiv ‚Ñù f y v‚ü´ = c * ‚ü™u, v‚ü´ := Œª y, conformal_at_iff'.mp $ hf.conformal_at y,
  have Q := similarity_factor_sqrt_inv_times_cont_diff_at hw x‚ÇÄ P (D22 $ hf' x‚ÇÄ hx‚ÇÄs),
  rw fderiv_smul,
  simp only [continuous_linear_map.add_apply, continuous_linear_map.smul_apply, 
             continuous_linear_map.smul_right_apply, congr_arg],
  have minor‚ÇÅ : ‚àÄ·∂† (x : E) in ùìù x‚ÇÄ, has_fderiv_at f (fderiv ‚Ñù f x) x := 
    filter.eventually_of_mem (is_open.mem_nhds hs hx‚ÇÄs) 
    (Œª a ha, ((hf' a ha).differentiable_at triv).has_fderiv_at),
  have minor‚ÇÇ : differentiable_at ‚Ñù (fderiv ‚Ñù f) x‚ÇÄ := D23 zero_lt_two (hf' x‚ÇÄ hx‚ÇÄs),
  have minor‚ÇÉ : ‚àÄ·∂† (x : E) in ùìù x‚ÇÄ, has_fderiv_at (Œª (y : E), similarity_factor_sqrt_inv $ P y) 
    (fderiv ‚Ñù (Œª (y : E), similarity_factor_sqrt_inv $ P y) x) x :=
    filter.eventually_of_mem (is_open.mem_nhds hs hx‚ÇÄs)
    (Œª a ha, ((similarity_factor_sqrt_inv_times_cont_diff_at hw a P $ 
    D22 $ hf' a ha).differentiable_at $ with_top.coe_le_coe.mpr one_le_two).has_fderiv_at),
  have minor‚ÇÑ : differentiable_at ‚Ñù (fderiv ‚Ñù (Œª (y : E), similarity_factor_sqrt_inv $ P y)) x‚ÇÄ :=
    D23 zero_lt_one Q,
  rw [DD1 minor‚ÇÅ minor‚ÇÇ, DD1 minor‚ÇÉ minor‚ÇÑ], 
  simp only [congr_arg],
  rw [second_derivative_symmetric_of_eventually minor‚ÇÅ minor‚ÇÇ.has_fderiv_at,
      second_derivative_symmetric_of_eventually minor‚ÇÉ minor‚ÇÑ.has_fderiv_at, add_comm],
  exact DD2 zero_lt_one Q v,
  exact DD2 zero_lt_two (hf' x‚ÇÄ hx‚ÇÄs) u
end

end tot_diff_eq

-- h = u
-- k = v
-- l = w